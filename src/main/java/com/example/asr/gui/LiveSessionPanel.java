/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package com.example.asr.gui;


//import com.example.asr.gui.components.ToggleSwitch;
import com.example.asr.transcriber.MicTranscriber;
import com.example.asr.config.AppConfig;
import com.example.asr.util.FileManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import javax.sound.sampled.LineUnavailableException;
import java.awt.*;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

/**
 *
 * @author by-nreyes
 */

public class LiveSessionPanel extends javax.swing.JPanel {

    private static final Logger logger = LoggerFactory.getLogger(LiveSessionPanel.class);

    // Paleta de colores solicitada
    private static final Color COLOR_BG_1 = new Color(212,224,155);
    private static final Color COLOR_BG_2 = new Color(246,244,210);
    private static final Color COLOR_BG_3 = new Color(203,223,189);
    private static final Color COLOR_ACCENT = new Color(241,156,121);
    private static final Color COLOR_TEXT = new Color(70,63,58);

    /**
     * Creates new form LiveSessionPanel
     */
    public LiveSessionPanel(MainFrame mainFrame) {
                initComponents();
                // Aplicar paleta desde AppConfig
                this.setBackground(AppConfig.COLOR_BG_2);
                textArea.setBackground(Color.WHITE);
                textArea.setForeground(AppConfig.COLOR_TEXT);
                jToggleButton.setBackground(AppConfig.COLOR_ACCENT);
                jToggleButton.setForeground(AppConfig.COLOR_TEXT);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jToggleButton = new javax.swing.JToggleButton();
        jScrollPane = new javax.swing.JScrollPane();
        textArea = new javax.swing.JTextArea();

        setBackground(new java.awt.Color(246, 244, 210));

        jToggleButton.setBackground(new java.awt.Color(241, 156, 121));
        jToggleButton.setFont(new java.awt.Font("Segoe UI Semibold", Font.BOLD, 12)); // NOI18N
        jToggleButton.setForeground(new java.awt.Color(70, 63, 58));
        jToggleButton.setSelected(false);
        jToggleButton.setText("OFF");
        jToggleButton.addActionListener(this::jToggleButtonActionPerformed);

        textArea.setColumns(20);
        textArea.setRows(10);
        textArea.setEditable(false);
        jScrollPane.setViewportView(textArea);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 340, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(110, 110, 110)
                .addComponent(jToggleButton)
                .addContainerGap(115, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 200, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jToggleButton)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButtonActionPerformed
        // Toggle inmediato: iniciar o detener según estado
        if (jToggleButton.isSelected()) {
            jToggleButton.setOpaque(true);
            jToggleButton.setText("ON");
            jToggleButton.setBackground(COLOR_BG_1);
            startSession();
        } else {
            stopSession();
        }
    }//GEN-LAST:event_jToggleButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JToggleButton jToggleButton;
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JTextArea textArea;
    // End of variables declaration//GEN-END:variables

    // Worker y transcriptor activos
    private transient MicTranscriber transcriber;
    private transient javax.swing.SwingWorker<Void, String> worker;

    // Método público para iniciar sesión
    public void startSession() {
        startTranscripcion();
    }

    // Método público para detener sesión
    public void stopSession() {
        stopTranscripcion();
    }

    /**
     * Limpia el área de transcripción.
     */
    public void clearTranscription() {
        textArea.setText("");
        logger.info("Transcripción limpiada");
    }

    /**
     * Guarda la sesión actual con un nombre personalizado.
     */
    public boolean saveSession(String sessionName) {
        if (sessionName == null || sessionName.trim().isEmpty()) return false;
        try {
            Path dest = FileManager.resolveSessionFile(sessionName);
            FileManager.saveTranscription(dest, textArea.getText());
            return true;
        } catch (IOException e) {
            logger.error("Error guardando sesión", e);
            textArea.append("Error guardando sesión: " + e.getMessage() + "\n");
            return false;
        }
    }

    /**
     * Obtiene la transcripción actual.
     */
    public String getCurrentTranscription() {
        return textArea.getText();
    }

    private void startTranscripcion() {
        // Evitar múltiples workers
        if (worker != null && !worker.isDone()) return;

        try {
            transcriber = new MicTranscriber(MainFrame.getVoskService());
        } catch (Exception e) {
            textArea.append("No se pudo inicializar Vosk: " + e.getMessage() + "\n");
            logger.error("Error inicializando MicTranscriber", e);
            return;
        }

        // Obtener ruta de archivo de salida
        Path outputFile;
        try {
            outputFile = FileManager.getLiveTranscriptionFile();
        } catch (IOException e) {
            textArea.append("No se pudo crear carpeta de transcripciones: " + e.getMessage() + "\n");
            logger.error("Error creando directorio de transcripciones", e);
            return;
        }

        // Crear SwingWorker para ejecución asíncrona
        final Path finalOutputFile = outputFile;
        worker = new SwingWorker<Void, String>() {

            @Override
            protected Void doInBackground() {
                try {
                    transcriber.startTranscription(text -> {
                        if (text != null && !text.isEmpty()) {
                            publish(text); // Enviar a UI thread
                            // Escribir en archivo
                            try {
                                FileManager.appendTranscription(finalOutputFile, text);
                            } catch (IOException e) {
                                logger.error("Error escribiendo transcripción", e);
                                publish("ERROR escribiendo archivo: " + e.getMessage());
                            }
                        }
                    });
                } catch (LineUnavailableException | IOException e) {
                    logger.error("Error en transcripción", e);
                    publish("ERROR: " + e.getMessage());
                } catch (Exception e) {
                    logger.error("Error inesperado en transcripción", e);
                    publish("ERROR inesperado: " + e.getMessage());
                }
                return null;
            }

            @Override
            protected void process(java.util.List<String> chunks) {
                for (String text : chunks) {
                    textArea.append(">>> " + text + "\n");
                }
            }
        };

        worker.execute();
        textArea.append("[Transcripción iniciada]\n");
    }

    private void stopTranscripcion() {
        logger.info("Deteniendo transcripción...");

        // Marcar transcriptor para detener (no bloqueante)
        if (transcriber != null) {
            transcriber.stop();
        }

        // Esperar a que el SwingWorker termine en un hilo background
        // para NO bloquear la UI
        if (worker != null && !worker.isDone()) {
            new Thread(() -> {
                try {
                    worker.get(AppConfig.SWING_WORKER_TIMEOUT_SECONDS, java.util.concurrent.TimeUnit.SECONDS);
                    logger.info("SwingWorker terminó correctamente");
                } catch (java.util.concurrent.TimeoutException e) {
                    logger.warn("Timeout esperando término del worker, cancelando...");
                    worker.cancel(true);
                } catch (Exception e) {
                    logger.warn("Error esperando término del worker: {}", e.getMessage());
                }
            }).start();
        }

        // Actualizar UI inmediatamente (sin esperar)
        if (jToggleButton != null) {
            jToggleButton.setSelected(false);
            jToggleButton.setText("OFF");
            jToggleButton.setOpaque(false);
            jToggleButton.setBackground(AppConfig.COLOR_ACCENT);
        }

        textArea.append("[Transcripción pausada]\n");
        logger.info("Transcripción pausada correctamente");
    }

}
